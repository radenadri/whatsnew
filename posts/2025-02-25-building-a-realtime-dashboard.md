---
title: Real-time Dashboard with Laravel, Livewire, and Alpine.js
slug: building-a-realtime-dashboard
author: John Smith
category: tutorials
tags: laravel, livewire, alpine, real-time
date: 2025-02-25
status: published
---

*Learn how to create a responsive, real-time admin dashboard using Laravel's powerful ecosystem.*

*This example article is generated by Claude Sonnet 3.7.*

**Last Updated:** February 25, 2025

## Prerequisites

Before we begin, make sure you have:

- [x] PHP 8.2+ installed
- [x] Composer installed
- [x] Basic knowledge of Laravel
- [ ] Familiarity with Livewire (helpful but not required)
- [ ] Experience with Alpine.js (helpful but not required)

## Introduction

Modern web applications often require real-time updates without full page reloads. In this tutorial, we'll build a dashboard that updates automatically when data changes. We'll use:

1. **Laravel** as our backend framework
2. **Livewire** for reactive components
3. **Alpine.js** for frontend interactivity

> "The combination of Laravel, Livewire, and Alpine.js creates a powerful stack for building dynamic applications without the complexity of a full JavaScript framework."
> 
> â€” Taylor Otwell, Creator of Laravel

## Setting Up the Project

Let's start by creating a new Laravel project:

```bash
composer create-project laravel/laravel real-time-dashboard
cd real-time-dashboard
```

Next, install Livewire and configure the assets:

```bash
composer require livewire/livewire
php artisan livewire:publish --assets
```

## Database Configuration

For our dashboard, we'll track the following metrics:

<table>
<thead>
  <tr>
    <th class="width-auto">Metrics</th>
    <th class="width-auto">Description</th>
    <th class="width-min">Update Frequency</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Active Users</td>
    <td>Currently online users</td>
    <td>Real-time</td>
  </tr>
  <tr>
    <td>Daily Sales</td>
    <td>Total sales for the day</td>
    <td>Every 5 minutes</td>
  </tr>
  <tr>
    <td>Conversion Rate</td>
    <td>Percentage of visitors who make a purchase</td>
    <td>Hourly</td>
  </tr>
  <tr>
    <td>Server Health</td>
    <td>CPU/Memory usage across servers</td>
    <td>Every minute</td>
  </tr>
</tbody>
</table>

Create the necessary migrations:

```php
public function up()
{
    Schema::create('metrics', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->string('display_name');
        $table->json('value');
        $table->string('type')->default('counter');
        $table->timestamps();
    });
}
```

## Creating the Livewire Component

Now, let's create a Livewire component for each dashboard widget:

```bash
php artisan make:livewire MetricCard
php artisan make:livewire ServerHealth
```

Implement the MetricCard component:

```php
namespace App\Http\Livewire;

use Livewire\Component;
use App\Models\Metric;

class MetricCard extends Component
{
    public $metric;
    public $name;
    public $value;
    public $previousValue;
    public $trend;
    
    protected $listeners = ['metricUpdated' => 'refreshMetric'];
    
    public function mount($metricName)
    {
        $this->name = $metricName;
        $this->refreshMetric();
    }
    
    public function refreshMetric()
    {
        $metric = Metric::where('name', $this->name)->first();
        
        if ($metric) {
            $this->metric = $metric;
            $this->previousValue = $this->value ?? 0;
            $this->value = $metric->value['current'];
            $this->calculateTrend();
        }
    }
    
    private function calculateTrend()
    {
        if ($this->previousValue > 0) {
            $change = ($this->value - $this->previousValue) / $this->previousValue * 100;
            $this->trend = [
                'direction' => $change >= 0 ? 'up' : 'down',
                'percentage' => abs(round($change, 1))
            ];
        } else {
            $this->trend = null;
        }
    }
    
    public function render()
    {
        return view('livewire.metric-card');
    }
}
```

## Creating Blade Views

Create the Blade view for our MetricCard component:

```html
<div class="bg-white rounded-lg shadow p-6" wire:poll.5s>
    <h3 class="text-gray-500 text-sm font-medium">{{ $metric->display_name }}</h3>
    
    <div class="mt-2 flex items-baseline">
        <div class="text-2xl font-semibold text-gray-900">
            {{ is_numeric($value) ? number_format($value) : $value }}
        </div>
        
        @if($trend)
            <span class="ml-2 flex items-baseline text-sm font-semibold {{ $trend['direction'] === 'up' ? 'text-green-600' : 'text-red-600' }}">
                @if($trend['direction'] === 'up')
                    <svg class="w-3 h-3 fill-current" viewBox="0 0 12 12">
                        <path d="M3 8l3-3 3 3"></path>
                    </svg>
                @else
                    <svg class="w-3 h-3 fill-current" viewBox="0 0 12 12">
                        <path d="M3 4l3 3 3-3"></path>
                    </svg>
                @endif
                {{ $trend['percentage'] }}%
            </span>
        @endif
    </div>
</div>
```

## Adding Alpine.js for Interactivity

Let's add a chart component using Alpine.js:

```html
<div class="bg-white rounded-lg shadow p-6" 
     x-data="{ 
         cpuData: @entangle('cpuData'),
         memoryData: @entangle('memoryData'),
         activeTab: 'cpu' 
     }"
     wire:poll.10s>
    
    <div class="flex mb-4 border-b">
        <button @click="activeTab = 'cpu'" 
                :class="{ 'border-blue-500 text-blue-600': activeTab === 'cpu' }"
                class="px-4 py-2 border-b-2 border-transparent">
            CPU Usage
        </button>
        <button @click="activeTab = 'memory'" 
                :class="{ 'border-blue-500 text-blue-600': activeTab === 'memory' }"
                class="px-4 py-2 border-b-2 border-transparent">
            Memory Usage
        </button>
    </div>
    
    <div x-show="activeTab === 'cpu'">
        <canvas id="cpuChart" x-init="initChart('cpuChart', cpuData)"></canvas>
    </div>
    
    <div x-show="activeTab === 'memory'" class="hidden">
        <canvas id="memoryChart" x-init="initChart('memoryChart', memoryData)"></canvas>
    </div>
</div>
```

## Adding Real-time Updates with Events

To make our dashboard truly real-time, we'll use Laravel's event system with WebSockets:

Install the required packages

```bash
composer require beyondcode/laravel-websockets pusher/pusher-php-server
```

```php
namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class MetricUpdated implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $metricName;
    public $value;

    public function __construct($metricName, $value)
    {
        $this->metricName = $metricName;
        $this->value = $value;
    }

    public function broadcastOn()
    {
        return new Channel('dashboard');
    }
}
```

## Performance Considerations

When building real-time dashboards, consider these performance factors:

<table>
<thead>
  <tr>
    <th class="width-auto">Consideration</th>
    <th class="width-min">Impact</th>
    <th class="width-auto">Solution</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Polling Frequency</td>
    <td>Higher server load</td>
    <td>Use appropriate polling intervals</td>
  </tr>
  <tr>
    <td>Data Freshness</td>
    <td>User experience</td>
    <td>Balance between real-time and performance</td>
  </tr>
  <tr>
    <td>Connection Count</td>
    <td>Server resources</td>
    <td>Use WebSockets for efficient connections</td>
  </tr>
  <tr>
    <td>Mobile Performance</td>
    <td>Battery usage</td>
    <td>Adaptive polling based on connection type</td>
  </tr>
</tbody>
</table>

## Conclusion

Your real-time dashboard is now complete! You've learned how to:

1. Set up Laravel with Livewire and Alpine.js
2. Create reactive dashboard components
3. Implement real-time updates with WebSockets
4. Build interactive charts and metrics displays

## Next Steps

Here are some ways to enhance your dashboard:

- [ ] Add user authentication and personalization
- [ ] Implement dashboard layout customization
- [ ] Add more visualization types
- [ ] Create alert notifications for metric thresholds

---

## Helpful Resources

1. [Laravel Documentation](https://laravel.com/docs)[^1]
2. [Livewire Documentation](https://laravel-livewire.com/docs)[^2]
3. [Alpine.js Documentation](https://alpinejs.dev/)[^3]

[^1]: Laravel's official documentation provides comprehensive guides for all core features.
[^2]: Livewire documentation includes many practical examples for reactive components.
[^3]: Alpine.js is a minimalist JavaScript framework for adding interactivity to your markup.

*Did you find this tutorial helpful? Let us know in the comments below!*
